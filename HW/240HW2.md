# Data Class 
คือ คลาสที่มีแต่ข้อมูล fields และเมธอดสำหรับเข้าถึงข้อมูลนั้น Getters/Setters โดยไม่มีฟังก์ชันการทำงาน methods/logic ที่ซับซ้อนอยู่เลย
* ปัญหา: เป็นการบ่งบอกว่า responsibility ในการจัดการข้อมูลนั้น จะตกไปอยู่ที่คลาสอื่นแทนที่จะเป็นตัวมันเอง ซึ่งขัดกับหลักการ "Tell, Don't Ask"
* ผลเสีย: ทำให้เกิด Feature Envy (คลาสอื่นมายุ่งกับข้อมูลของคลาสนี้มากเกินไป) และทำให้การแก้ไขโค้ดทำได้ยาก เพราะ Logic กระจัดกระจายไปอยู่ผิดที่

## ตัวอย่าง code ที่เกิด code smell
สมมติเรามีคลาส Order ที่เป็น Data Class และมีคลาส OrderProcessor ที่ดึงข้อมูลไปคำนวณเอง
~~~
//  Data Class: มีแต่ data และ getter/setter
public class Order {
    private List<LineItem> items;
    private double taxRate;

    public Order(List<LineItem> items, double taxRate) {
        this.items = items;
        this.taxRate = taxRate;
    }

    public List<LineItem> getItems() { return items; }
    public double getTaxRate() { return taxRate; }
}

// Client Code: Logic การคำนวณไปกองอยู่ที่อื่น
public class OrderProcessor {
    public double calculateTotal(Order order) {
        double subTotal = 0;
        // ต้อง "ล้วง" ข้อมูลออกมา (Ask) แล้วคำนวณเอง
        for (LineItem item : order.getItems()) {
            subTotal += item.getPrice() * item.getQuantity();
        }
        return subTotal + (subTotal * order.getTaxRate());
    }
}
~~~

## ตัวอย่างโค้ดที่ Refactoring แล้ว
การใช้เทคนิค **Move Method** คือย้าย Logic ที่เกี่ยวข้องกับข้อมูลนั้น กลับเข้าไปใส่ในคลาสที่เป็นเจ้าของข้อมูล
~~~

// Refactored: Order มีความฉลาดในตัวเอง (Encapsulation)
public class Order {
    private List<LineItem> items;
    private double taxRate;

    public Order(List<LineItem> items, double taxRate) {
        this.items = items;
        this.taxRate = taxRate;
    }

    // ย้าย Logic การคำนวณมาไว้ที่นี่
    public double calculateTotal() {
        double subTotal = 0;
        for (LineItem item : items) {
            subTotal += item.getPrice() * item.getQuantity();
        }
        return subTotal + (subTotal * taxRate);
    }
}

// Client Code: สั่งให้ Order ทำงาน (Tell)
public class OrderProcessor {
    public double processOrder(Order order) {
        return order.calculateTotal();
    }
}
~~~

ถ้า class ที่เก็บข้อมูล public fields ใช้การ **Encapsulated field** เพื่อที่จะซ่อนจากการเข้าถึงโดยตรง และต้องกำหนดให้เข้าถึงได้โดย getters/setters เท่านั้น **Encapsulated collection** ใช้เพื่อเก็บข้อมูลใน collection ( arrays) 
หลังจากที่ class นั้นได้มีการใช้ methods ที่ดีแล้วเราสามารถลบ methods เก่าได้นั่นคือ ใช้การ **Remove Setting Method และ Hide Method**

## กรณีที่ code smell ไม่ได้บ่งบอกถึงโค้ดที่มีปัญหา
**Data Transfer Objects (DTO):**
* เมื่อต้องการส่งข้อมูลข้าม Layer (เช่น ระหว่าง Database กับ UI, หรือส่งผ่าน JSON API) เราต้องการ object ที่โง่ๆ (Dumb object) เพื่อแค่ห่อหุ้มข้อมูลส่งผ่านไปมา การใส่ Logic ลงไปใน DTO อาจทำให้เกิด Dependency ที่ไม่จำเป็น

  
**Immutable Value Objects:**
* ในบางกรณีเราต้องการ object เล็กๆ เพื่อแทนค่าบางอย่าง (เช่น Coordinates, Money, DateRange) ซึ่งมีแค่ data และ getter โดยไม่มี logic ซับซ้อน ถือเป็นเรื่องปกติ

  
**Functional Programming Style:**
* หากคุณเขียนโค้ดโดยเน้นสไตล์ Functional ซึ่งแยก Data ออกจาก Behavior อย่างชัดเจน การมี Data Class (เช่น record ใน Java 14+ หรือ dataclass ใน Python) ถือเป็นเรื่องปกติและไม่ใช่ Code Smell ในบริบทนั้น
